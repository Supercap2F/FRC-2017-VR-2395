import cv2
import numpy
import math
#from enum import Enum


class GripPipeline:
    """
    An OpenCV pipeline generated by GRIP.
    """
    
    def __init__(self):
        """initializes all values to presets or None if need to be set
        """

        self.__hsv_threshold_hue = [40.46762589928058, 74.02730375426621]
        self.__hsv_threshold_saturation = [18.345323741007192, 135.33276450511946]
        self.__hsv_threshold_value = [43.00872861033209, 117.92662116040955]

        self.hsv_threshold_output = None


    def process(self, source0):
        """
        Runs the pipeline and sets all outputs to new values.
        """
        # Step HSV_Threshold0:
        self.__hsv_threshold_input = source0
        (self.hsv_threshold_output) = self.__hsv_threshold(self.__hsv_threshold_input, self.__hsv_threshold_hue, self.__hsv_threshold_saturation, self.__hsv_threshold_value)


    @staticmethod
    def __hsv_threshold(input, hue, sat, val):
        """Segment an image based on hue, saturation, and value ranges.
        Args:
            input: A BGR numpy.ndarray.
            hue: A list of two numbers the are the min and max hue.
            sat: A list of two numbers the are the min and max saturation.
            lum: A list of two numbers the are the min and max value.
        Returns:
            A black and white numpy.ndarray.
        """
        out = cv2.cvtColor(input, cv2.COLOR_BGR2HSV)
        return cv2.inRange(out, (hue[0], sat[0], val[0]),  (hue[1], sat[1], val[1]))




#Capture = cv2.VideoCapture(0)
#Capture.set(10, 0.1);
#Capture.set(11, 0.1);
#Capture.set(12, 0.1);

    
pipe = GripPipeline()


#while True:
#ret_vaule, frame = Capture.read();

cXa = []
cYa = []

while True:
    cntsDetected=0;
    x=0

    
    frame = cv2.imread("./ImgCap/img4.jpg")
    #ret_vaule, frame = Capture.read();
    ratio = frame.shape[0];

    pipe.process(frame);

    cnts = cv2.findContours(pipe.hsv_threshold_output.copy(), cv2.RETR_EXTERNAL,
                                cv2.CHAIN_APPROX_SIMPLE)[0]


    # loop over the contours
    for c in cnts:
            # compute the center of the contour, then detect the name of the
            # shape using only the contour
            #M = cv2.moments(c)
            cX = 240
            cY = 320
            x = x + 1
            #shape = detector.detect(c)

            # multiply the contour (x, y)-coordinates by the resize ratio,
            # then draw the contours and the name of the shape on the image
            #c = c.astype("float")
            #c *= ratio
            #c = c.astype("int")

            peri = cv2.arcLength(c, True)
	    approx = cv2.approxPolyDP(c, 0.04 * peri, True)

	    if len(approx) >= 4 and len(approx) <= 6 : # only draw contours if they have four vertex

                (x, y, w, h) = cv2.boundingRect(approx) # get the approximated rectangle dimensions
		hw = h / float(w)

		if hw >= 1.4 and hw <= 2.9:
                    cntsDetected = cntsDetected + 1;

                    if cntsDetected == 1:
                        cntOneMoment = cv2.moments(c)
                    elif cntsDetected == 2:
                        cntTwoMoment = cv2.moments(c)

                    
                    m = cv2.moments(c)

                    cv2.circle(frame, (int(m['m10']/m['m00']), int(m['m01']/m['m00'])), 1, (0,0,255))
                    
                    cv2.drawContours(frame, [c], -1, (0, 255, 0), 2)

    if cntsDetected == 2: # if the right amount of contours where detected
        cXone = int(cntOneMoment['m10']/cntOneMoment['m00'])
        cYone = int(cntOneMoment['m01']/cntOneMoment['m00'])
        cXtwo = int(cntTwoMoment['m10']/cntTwoMoment['m00'])
        cYtwo = int(cntTwoMoment['m01']/cntTwoMoment['m00'])

        XcenterGoal = int((cXone + cXtwo) / 2)
        YcenterGoal = int((cYone + cYtwo) / 2)

        cv2.circle(frame, (int(XcenterGoal), int(YcenterGoal)), 1, (0,255,0))
        
    else:
        print "Error: " + cntsDetected + " detected instead of 2"



    
    cv2.imshow("Image", frame)
    if cv2.waitKey(1) == 27:
           break;



    


print len(approx)
    

cv2.destroyAllWindows(); # destroy the image window 





    

